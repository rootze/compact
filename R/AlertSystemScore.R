#==============================================
# NOTE AlertSystemScore
#==============================================

#' .create_msg: internal message helper factory
#'
#' Internal helper that returns a message-emitting function controlled by a
#' logical \code{verbose} flag. When \code{verbose = TRUE}, the returned function
#' forwards its arguments to \code{message()}; otherwise it is silent.
#'
#' @param verbose Logical; whether messages should be emitted.
#'
#' @return A function that conditionally emits messages.
#'
#' @keywords internal
#' @noRd
.create_msg <- function(verbose) {
  force(verbose)
  function(...) {
    if (isTRUE(verbose)) message(...)
  }
}


## ================================
## Main function
## ================================

#' AlertSystem: score pathway gene sets for a given module perturbation
#'
#' This function implements the AlertSystem pathway scoring workflow for a
#' single module perturbation. It:
#' \enumerate{
#'   \item Filters the input gene sets to features present in the Seurat object.
#'   \item Computes UCell scores for each gene set on the baseline assay
#'         (e.g. \code{"RNA"}) and on the perturbation assay
#'         (e.g. \code{"M6_up"}).
#'   \item Computes per-pathway log2 fold-changes,
#'         \eqn{ \log_2 \left( \frac{\mathrm{post} + \varepsilon}{\mathrm{pre} + \varepsilon} \right) }.
#'   \item Aggregates logFC per group (if \code{group.by} is provided) or
#'         across all cells, and computes group-wise metrics including:
#'         \itemize{
#'           \item \emph{effect}: mean/median logFC,
#'           \item \emph{concordance}: fraction of cells whose logFC sign matches
#'                 the group-level effect sign.
#'           \item \emph{robustness} (optional): fraction of cells whose
#'                 logFC is both (i) above the magnitude threshold
#'                 (|logFC| ≥ \code{robust_effect_thresh}) and
#'                 (ii) has the same sign as the group-level effect.
#'         }
#'   \item Extracts all UCell (pre/post) and logFC columns created during
#'         scoring and stores them, along with the metrics table and
#'         run parameters, in \code{seurat_obj@misc$AlertSystem}.
#'   \item Optionally saves all AlertSystem results as a single RDS file
#'         (containing \code{seurat_obj@misc$AlertSystem}) and exports the
#'         pathway-level metrics table as a CSV file in \code{out_dir}.
#'   \item Restores the original \code{seurat_obj@meta.data}, so that the
#'         object is not permanently bloated by intermediate score columns.
#' }
#'
#' @param seurat_obj A Seurat object that already contains the perturbation
#'   assay generated by \code{ModulePerturbation} (e.g. an assay named
#'   \code{"M6_up"}).
#' @param gene_sets Named list of character vectors, each defining a pathway
#'   gene set to score.
#' @param perturbation_name Name of the perturbation assay in \code{seurat_obj}
#'   (e.g. \code{"M6_up"}).
#' @param base_tag Character string used to construct suffixes for baseline,
#'   perturbation and logFC columns. For example, if \code{base_tag = "M6"}
#'   and \code{baseline_assay = "RNA"}, generated columns will end in
#'   \code{"_M6_RNA"}, \code{"_M6_M6up"}, and \code{"_M6_logFC"}.
#' @param baseline_assay Name of the baseline assay to use for pre-perturbation
#'   UCell scoring (default \code{"RNA"}).
#' @param group.by Optional metadata column name used to group cells for
#'   summarization. If \code{NULL}, all cells are treated as a single group
#'   named \code{"all_cells"}.
#' @param out_dir Optional directory where AlertSystem outputs will be saved.
#'   If provided, the function writes a single RDS file containing the full
#'   \code{seurat_obj@misc$AlertSystem} list (AlertSystem_info) and a CSV
#'   file with the pathway-level metrics table. If \code{NULL}, results are
#'   not written to disk.
#' @param min_genes Minimum number of genes required to retain a gene set
#'   after intersecting with the Seurat object's feature set.
#' @param eps Small numeric constant, epsilon, added to pre and post scores in the
#'   logFC computation to avoid division by zero.
#' @param summary_fun Aggregation function used for group-wise effect
#'   computation in the metrics table, one of \code{"mean"} or \code{"median"}.
#' @param return_details Logical; if \code{FALSE} (default), the function
#'   returns only the updated Seurat object with results stored under
#'   \code{seurat_obj@misc$AlertSystem}. If \code{TRUE}, a list is returned
#'   containing the Seurat object, per-cell scores, metrics table, and any
#'   file paths used for saving.
#' @param verbose Logical; if \code{TRUE} (default), progress messages are printed
#'   during scoring and summarization. Set to \code{FALSE} to suppress console output.
#' @param compute_concordance Logical; if \code{TRUE} (default), compute a
#'   concordance score per group × pathway as the fraction of cells whose logFC
#'   sign matches the group-level effect sign.
#' @param compute_robustness Logical; if \code{TRUE} (default), a robustness metric is computed
#'   per group × pathway as the fraction of all cells whose logFC is both
#'   (i) above the magnitude threshold (|logFC| ≥ \code{robust_effect_thresh})
#'   and (ii) has the same sign as the group-level effect.
#' @param robust_effect_thresh Numeric threshold on per-cell logFC used to define
#'   "strong responders" in the robustness metric \code{robust_gt_thresh}.
#'   For each group × pathway, \code{robust_gt_thresh} is the fraction of all
#'   cells whose logFC is both (i) above this magnitude threshold
#'   (|logFC| ≥ \code{robust_effect_thresh}) and (ii) has the same sign as the
#'   group-level effect. If \code{robust_effect_thresh = 0}, this metric is
#'   not computed and \code{robust_gt_thresh} is set to \code{NA}.
#'
#' @return If \code{return_details = FALSE} (default), returns the Seurat
#'   object with \code{seurat_obj@misc$AlertSystem} populated and the
#'   original metadata restored. If \code{return_details = TRUE}, returns a
#'   list with elements:
#'   \describe{
#'     \item{seurat}{The updated Seurat object.}
#'     \item{per_cell}{Data frame of per-cell UCell and logFC scores
#'           (also stored in \code{seurat_obj@misc$AlertSystem$per_cell}).}
#'     \item{metrics}{Long-format data frame of group-wise metrics
#'           (effect, concordance, robustness) for each pathway
#'           (also stored in \code{seurat_obj@misc$AlertSystem$metrics}).}
#'     \item{info_file}{Path to the RDS file storing the full
#'           \code{seurat_obj@misc$AlertSystem} list (or \code{NULL} if
#'           \code{out_dir} was not provided).}
#'     \item{metrics_file}{Path to the CSV file containing the metrics table
#'           (or \code{NULL} if \code{out_dir} was not provided).}
#'   }
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Load pathway gene sets (local directory or GitHub fallback)
#' alertdatabasePATH <- "/dataPATH/"
#' genetype <- "mouse"  # or "human"
#'
#' gene_sets_mouse <- LoadAlertSystemPathways(
#'   path = alertdatabasePATH,
#'   genetype= "mouse",
#'   database = "MSigDBhallmark"
#' )
#'
#' # Basic usage: concordance on, robustness on (default)
#' seurat_obj <- AlertSystemScore(
#'   seurat_obj         = seurat_obj,
#'   gene_sets          = gene_sets_mouse,
#'   perturbation_name  = "M6_up",
#'   base_tag           = "M6",
#'   baseline_assay     = "RNA",
#'   group.by           = "cell_types_broad",
#'   out_dir            = tempdir(),   # save AlertSystem_info RDS + metrics CSV
#'   verbose            = TRUE
#' )
#'
#' # Access metrics (effect + concordance + robustness)
#' head(seurat_obj@misc$AlertSystem$metrics)
#'
#' # Example with a stricter robustness threshold
#' res <- AlertSystemScore(
#'   seurat_obj          = seurat_obj,
#'   gene_sets           = gene_sets_mouse,
#'   perturbation_name   = "M6_up",
#'   base_tag            = "M6",
#'   baseline_assay      = "RNA",
#'   group.by            = "cell_types_broad",
#'   compute_robustness = TRUE,
#'   robust_effect_thresh  = 0.1,   # only count cells with |logFC| ≥ 0.1
#'   return_details      = TRUE,
#'   verbose             = TRUE
#' )
#'
#' head(res$metrics)
#' }

AlertSystemScore <- function(
  seurat_obj,
  gene_sets,
  perturbation_name,
  base_tag,
  baseline_assay = "RNA",
  group.by       = NULL,
  out_dir        = NULL,
  min_genes      = 5,
  eps            = 1e-10,
  summary_fun    = c("mean", "median"),
  return_details = FALSE,
  verbose        = TRUE,
  compute_concordance   = TRUE,
  compute_robustness = TRUE,
  robust_effect_thresh  = 0.01
) {
  summary_fun <- match.arg(summary_fun)
  misc_name <- "AlertSystem"

  .msg <- .create_msg(verbose)

  .msg("── AlertSystemScore: Starting pathway scoring for perturbation: ", perturbation_name)

  # 0) Save original metadata
  .msg("• Saving original metadata...")
  original_meta <- seurat_obj@meta.data

  # 1) Filter gene sets
  .msg("• Filtering gene sets to genes present in Seurat object...")
  gene_sets_filtered <- .filter_gene_sets_for_obj(
    gs_list   = gene_sets,
    seu_obj   = seurat_obj,
    min_genes = min_genes
  )
  .msg("    → Retained ", length(gene_sets_filtered), " gene sets")

  if (length(gene_sets_filtered) == 0L) {
    stop("No gene sets retained after filtering.")
  }

  # 2) Suffixes
  .msg("• Preparing suffixes for UCell and logFC columns...")
  pre_suffix   <- paste0("_", base_tag, "_", gsub("_", "", baseline_assay))
  post_suffix  <- paste0("_", base_tag, "_", gsub("_", "", perturbation_name))
  logfc_suffix <- paste0("_", base_tag, "_logFC")

  # 3) UCell scoring
  .msg("• Computing UCell scores (baseline assay: ", baseline_assay, ")...")
  if (!rlang::is_installed("UCell")) {
    stop("Package 'UCell' is required. Please install.packages('UCell').")
  }

  seurat_obj <- UCell::AddModuleScore_UCell(
    seurat_obj,
    features = gene_sets_filtered,
    name     = pre_suffix,
    assay    = baseline_assay
  )

  .msg("• Computing UCell scores (perturbation assay: ", perturbation_name, ")...")
  seurat_obj <- UCell::AddModuleScore_UCell(
    seurat_obj,
    features = gene_sets_filtered,
    name     = post_suffix,
    assay    = perturbation_name
  )

  # 4) logFC
  .msg("• Computing log2 fold-change (logFC) values...")
  seurat_obj <- .add_logfc_scores(
    seurat_obj   = seurat_obj,
    pre_suffix   = pre_suffix,
    post_suffix  = post_suffix,
    logfc_suffix = logfc_suffix,
    eps          = eps
  )

  # 5) per-cell extraction (UCell pre/post + logFC)
  .msg("• Extracting per-cell UCell + logFC columns...")
  pattern <- paste0("(", pre_suffix, "|", post_suffix, "|", logfc_suffix, ")$")
  per_cell_cols <- grep(pattern, colnames(seurat_obj@meta.data), value = TRUE)
  .msg("    → Found ", length(per_cell_cols), " columns to extract")

  if (length(per_cell_cols) == 0L) {
    per_cell_df <- seurat_obj@meta.data[, 0, drop = FALSE]
  } else {
    per_cell_df <- seurat_obj@meta.data[, per_cell_cols, drop = FALSE]
  }

  # # 5) summarize
  # .msg("• Summarizing logFC values",
  #       if (!is.null(group.by)) paste0(" by '", group.by, "'...") else " across all cells...")
  #
  # summary_df <- .summarize_module_scores(
  #   seurat_obj    = seurat_obj,
  #   score_pattern = paste0(logfc_suffix, "$"),
  #   group.by      = group.by,
  #   fun           = summary_fun
  # )

  # # 6) optional: compute concordance + robustness metrics
  # metrics_df <- NULL
  # if (isTRUE(compute_concordance) || isTRUE(compute_robustness)) {
  #   .msg("• Computing concordance and/or robustness metrics...")
  #   metrics_df <- .compute_alert_metrics(
  #     seurat_obj          = seurat_obj,
  #     score_pattern       = paste0(logfc_suffix, "$"),
  #     group.by            = group.by,
  #     fun                 = summary_fun,
  #     compute_concordance   = compute_concordance,
  #     compute_robustness = compute_robustness,
  #     n_boot              = n_boot,
  #     robust_effect_thresh  = robust_effect_thresh
  #   )
  # }
  # 6) compute group-wise metrics (effect always; concordance/robustness optional)
  .msg("• Computing group-wise metrics (effect, concordance, and robustness as fraction of strong sign-consistent cells)...")
  pert_tag <- gsub("_", "", perturbation_name)

  metrics_df <- .compute_alert_metrics(
    seurat_obj           = seurat_obj,
    score_pattern        = paste0(logfc_suffix, "$"),
    group.by             = group.by,
    fun                  = summary_fun,
    compute_concordance  = compute_concordance,
    compute_robustness   = compute_robustness,
    robust_effect_thresh = robust_effect_thresh,
    base_tag             = base_tag,
    pert_tag             = pert_tag
  )


  # 7) store in misc$AlertSystem
  .msg("• Storing results in seurat_obj@misc$AlertSystem ...")
  if (is.null(seurat_obj@misc[[misc_name]])) {
    seurat_obj@misc[[misc_name]] <- list()
  }

  seurat_obj@misc[[misc_name]][["per_cell"]] <- per_cell_df
  seurat_obj@misc[[misc_name]][["metrics"]]  <- metrics_df

  seurat_obj@misc[[misc_name]][["params"]]   <- list(
    base_tag            = base_tag,
    perturbation_name   = perturbation_name,
    baseline_assay      = baseline_assay,
    group.by            = group.by,
    min_genes           = min_genes,
    eps                 = eps,
    summary_fun         = summary_fun,
    compute_concordance = compute_concordance,
    compute_robustness  = compute_robustness,
    robust_effect_thresh = robust_effect_thresh,
    # NEW: useful extras for reproducibility
    timestamp           = Sys.time(),
    package_version     = tryCatch(
      as.character(utils::packageVersion("compact")),
      error = function(e) NA_character_
    ),
    # optionally store the names of the filtered pathways
    pathways            = names(gene_sets_filtered)
  )

  # 8) optional disk saving:
  #    - AlertSystem_info: single RDS with the full misc[[misc_name]] list
  #    - metrics CSV: easy-to-inspect pathway metrics
  info_file   <- NULL
  metrics_file <- NULL

  if (!is.null(out_dir)) {
    .msg("• Saving AlertSystem outputs to local directory: ", out_dir)

    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    safe_pert <- gsub("[^A-Za-z0-9]+", "_", perturbation_name)

    # 8a) RDS with full AlertSystem info (incl. per_cell + metrics + params)
    info_file <- file.path(
      out_dir,
      paste0("AlertSystem_", base_tag, "_", safe_pert, "_AlertSystem_info.rds")
    )
    saveRDS(seurat_obj@misc[[misc_name]], info_file)
    .msg("    → Saved full AlertSystem info to: ", info_file)

    # 8b) CSV with metrics table only (easier to inspect / share)
    metrics_file <- file.path(
      out_dir,
      paste0("AlertSystem_", base_tag, "_", safe_pert, "_metrics.csv")
    )
    utils::write.csv(metrics_df, file = metrics_file, row.names = FALSE)
    .msg("    → Saved metrics table to: ", metrics_file)

    # record paths inside misc$AlertSystem
    seurat_obj@misc[[misc_name]][["info_file"]]    <- info_file
    seurat_obj@misc[[misc_name]][["metrics_file"]] <- metrics_file
  }

  # 9) restore original metadata
  .msg("• Restoring original seurat_obj@meta.data...")
  seurat_obj@meta.data <- original_meta

  # Done!
  .msg("── AlertSystemScore: Completed successfully.")

  # 10) return
  if (!return_details) {
    return(seurat_obj)
  } else {
    return(list(
      seurat       = seurat_obj,
      per_cell     = per_cell_df,
      metrics      = metrics_df,
      info_file    = info_file,
      metrics_file = metrics_file
    ))
  }


}

#======================
# # NOTE updates on the information storage of misc$AlertSystem, # the code block from #7) to 10) below out, replacement above
#======================
  # # 7) store in misc$AlertSystem
  # .msg("• Storing results in seurat_obj@misc$AlertSystem ...")
  # if (is.null(seurat_obj@misc[[misc_name]])) {
  #   seurat_obj@misc[[misc_name]] <- list()
  # }
  #
  # seurat_obj@misc[[misc_name]][["per_cell"]] <- per_cell_df
  # seurat_obj@misc[[misc_name]][["metrics"]]  <- metrics_df
  # # seurat_obj@misc[[misc_name]][["summary"]]  <- summary_df
  # # seurat_obj@misc[[misc_name]][["params"]]   <- list(
  # #   base_tag          = base_tag,
  # #   perturbation_name = perturbation_name,
  # #   baseline_assay    = baseline_assay,
  # #   group.by          = group.by,
  # #   min_genes         = min_genes,
  # #   eps               = eps,
  # #   summary_fun       = summary_fun
  # # )
  # seurat_obj@misc[[misc_name]][["params"]]   <- list(
  #   base_tag            = base_tag,
  #   perturbation_name   = perturbation_name,
  #   baseline_assay      = baseline_assay,
  #   group.by            = group.by,
  #   min_genes           = min_genes,
  #   eps                 = eps,
  #   summary_fun         = summary_fun,
  #   compute_concordance   = compute_concordance,
  #   compute_robustness = compute_robustness,
  #   robust_effect_thresh  = robust_effect_thresh
  # )
  #
  # # 8) optional disk saving
  # per_cell_file <- metrics_file <- NULL
  # if (!is.null(out_dir)) {
  #   .msg("• Saving results to local directory: ", out_dir)
  #
  #   if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
  #
  #   safe_pert <- gsub("[^A-Za-z0-9]+", "_", perturbation_name)
  #
  #   per_cell_file <- file.path(
  #     out_dir,
  #     paste0("AlertSystem_", base_tag, "_", safe_pert, "_per_cell.rds")
  #   )
  #   saveRDS(per_cell_df, per_cell_file)
  #   .msg("    → Saved per-cell data to: ", per_cell_file)
  #
  #   metrics_file <- file.path(
  #     out_dir,
  #     paste0("AlertSystem_", base_tag, "_", safe_pert, "_metrics.rds")
  #   )
  #   saveRDS(metrics_df, metrics_file)
  #   .msg("    → Saved metrics table to: ", metrics_file)
  #
  #   seurat_obj@misc[[misc_name]][["per_cell_file"]] <- per_cell_file
  #   seurat_obj@misc[[misc_name]][["metrics_file"]]   <- metrics_file
  # }
  #
  #
  # # 9) restore original metadata
  # .msg("• Restoring original seurat_obj@meta.data...")
  # seurat_obj@meta.data <- original_meta
  #
  # # Done!
  # .msg("── AlertSystemScore: Completed successfully.")
  #
  # # 10) return
  # # if (!return_details) {
  # #   return(seurat_obj)
  # # } else {
  # #   return(list(
  # #     seurat        = seurat_obj,
  # #     per_cell      = per_cell_df,
  # #     summary       = summary_df,
  # #     per_cell_file = per_cell_file,
  # #     summary_file  = summary_file
  # #   ))
  # # }
  # if (!return_details) {
  #   return(seurat_obj)
  # } else {
  #   return(list(
  #     seurat        = seurat_obj,
  #     per_cell      = per_cell_df,
  #     metrics       = metrics_df,
  #     per_cell_file = per_cell_file,
  #     metrics_file  = metrics_file
  #   ))
  # }
#======================


#' Save the full AlertSystem state to disk
#'
#' This helper writes the complete \code{seurat_obj@misc[[misc_name]]}
#' list to an RDS file, so that AlertSystem results can be re-attached
#' later without recomputing. This is equivalent to the RDS file written
#' by \code{AlertSystemScore(..., out_dir = ...)} (the
#' \code{*_AlertSystem_info.rds} file), but can be called manually at
#' any time.
#'
#' @param seurat_obj A Seurat object with AlertSystem results stored in
#'   \code{seurat_obj@misc[[misc_name]]}.
#' @param file Path to an .rds file where the state will be saved
#'   (e.g. \code{"AlertSystem_M6_M6_up_AlertSystem_info.rds"}).
#' @param misc_name Name of the misc slot containing AlertSystem results.
#'   Default: \code{"AlertSystem"}.
#'
#' @return Invisibly returns \code{file}.
#' @export

SaveAlertSystem <- function(
  seurat_obj,
  file,
  misc_name = "AlertSystem"
) {
  if (is.null(seurat_obj@misc[[misc_name]])) {
    stop("No AlertSystem state found in seurat_obj@misc[['", misc_name, "']].")
  }
  saveRDS(seurat_obj@misc[[misc_name]], file = file)
  invisible(file)
}



#' Load a previously saved AlertSystem state into a Seurat object
#'
#' This helper reads an AlertSystem RDS file (created by
#' \code{AlertSystemScore(..., out_dir = ...)} or \code{SaveAlertSystem()})
#' and attaches it to \code{seurat_obj@misc[[misc_name]]}.
#'
#' Typically, this RDS file will be the
#' \code{*_AlertSystem_info.rds} file written by \code{AlertSystemScore},
#' which contains \code{per_cell}, \code{metrics}, and \code{params} in a
#' single list. Any associated metrics CSV (e.g.
#' \code{*_metrics.csv}) is not required for loading and plotting, but
#' can be inspected separately.
#'
#' Note: this does \emph{not} modify \code{seurat_obj@meta.data}; per-cell
#' scores remain accessible via \code{seurat_obj@misc[[misc_name]]$per_cell}.
#'
#' @param seurat_obj A Seurat object.
#' @param file Path to an RDS file containing an AlertSystem list
#'   (e.g. \code{"AlertSystem_M6_M6_up_AlertSystem_info.rds"}).
#' @param misc_name Name of the misc slot where the state should be stored.
#'   Default: \code{"AlertSystem"}.
#' @param overwrite Logical; if \code{FALSE} and a state already exists at
#'   \code{misc_name}, an error is thrown. Default: \code{TRUE}.
#' @param verbose Logical; print a short message upon successful load.
#'
#' @return The updated Seurat object.
#' @export
#'
#' @examples
#' \dontrun{
# 2) Later (or in a fresh R session), re-attach state:
#' test_obj <- LoadAlertSystem(
#'   seurat_obj = test_obj,
#'   file       = "PathToAlertSystemResults/AlertSystem_XXXXXX_AlertSystem_info.rds"
#' )
#' }

LoadAlertSystem <- function(
  seurat_obj,
  file,
  misc_name = "AlertSystem",
  overwrite = TRUE,
  verbose   = TRUE
) {
  if (!file.exists(file)) {
    stop("AlertSystem RDS file not found: ", file)
  }

  if (!overwrite && !is.null(seurat_obj@misc[[misc_name]])) {
    stop("seurat_obj@misc[['", misc_name, "']] already exists and overwrite = FALSE.")
  }

  obj <- readRDS(file)

  if (!is.list(obj)) {
    stop("Loaded object is not a list. Is this an AlertSystem RDS file?")
  }

  seurat_obj@misc[[misc_name]] <- obj

  if (verbose) {
    msg <- "Loaded AlertSystem state into seurat_obj@misc[['%s']]."
    message(sprintf(msg, misc_name))
  }

  seurat_obj
}



#' Load AlertSystem pathway gene sets (local or GitHub)
#'
#' This loads pathway gene sets from a local directory (if \code{path} is
#' provided) or automatically downloads them from GitHub if \code{path = NULL}.
#'
#' Filenames follow the pattern:
#'   \code{<database>_gene_sets_<genetype>.rds}
#'
#' @param path Optional local directory OR full file path. If \code{NULL},
#'   the function downloads the gene sets automatically from GitHub.
#' @param genetype Either \code{"mouse"} or \code{"human"}.
#' @param database Prefix used in filenames. Default: \code{"MSigDBhallmark"}.
#'
#' @return A named list of gene sets, where each element is a character vector
#'   of gene symbols corresponding to a pathway.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Load pathway gene sets (local directory or GitHub fallback)
#' alertdatabasePATH <- "/dataPATH/"
#' genetype <- "mouse"  # or "human"
#'
#' # Local
#' gene_sets_mouse <- LoadAlertSystemPathways(
#'   path = alertdatabasePATH,
#'   genetype= "mouse",
#'   database = "MSigDBhallmark"
#' )
#'
#' # GitHub
#' # Load mouse MSigDB Hallmark pathways (GitHub fallback by default)
#' gene_sets_mouse <- LoadAlertSystemPathways(
#'   genetype = "mouse",
#'   database = "MSigDBhallmark"
#' )
#'
#' # Load human MSigDB Hallmark pathways
#' gene_sets_human <- LoadAlertSystemPathways(
#'   genetype = "human",
#'   database = "MSigDBhallmark"
#' )
#'
#' }

LoadAlertSystemPathways <- function(
  path     = NULL,
  genetype = c("mouse", "human"),
  database  = "MSigDBhallmark"
) {
  genetype <- match.arg(genetype)

  # INTERNAL constant — not user exposed
  github_base <- "https://raw.githubusercontent.com/rootze/AlertSystem/main/data"

  fname <- paste0(database, "_gene_sets_", genetype, ".rds")

  ## -----------------------
  ## CASE 1: LOCAL LOAD
  ## -----------------------
  if (!is.null(path)) {
    # If the user gave a full file path, accept it
    if (grepl("\\.rds$", path)) {
      rds_path <- path
    } else {
      rds_path <- file.path(path, fname)
    }

    if (!file.exists(rds_path)) {
      stop("Gene set RDS file not found at: ", rds_path)
    }

    return(readRDS(rds_path))
  }

  ## -----------------------
  ## CASE 2: AUTO-LOAD FROM GITHUB
  ## -----------------------
  url <- paste0(
    sub("/$", "", github_base), "/", fname
  )

  message("LoadAlertSystemPathways: downloading gene sets from:\n  ", url)

  tmp <- tempfile(fileext = ".rds")
  utils::download.file(url, tmp, mode = "wb", quiet = TRUE)

  obj <- readRDS(tmp)

  if (!is.list(obj) || is.null(names(obj))) {
    warning("Loaded object is not a named list; check GitHub file format.")
  }

  obj
}



## ================================
## Internal helpers
## ================================

#' Filter gene sets to genes present in a Seurat object
#'
#' This internal helper takes a list of gene sets and restricts each set
#' to features present in the provided Seurat object. Gene sets with fewer
#' than \code{min_genes} genes after filtering are dropped.
#'
#' @param gs_list Named list of character vectors, each one a gene set.
#' @param seu_obj A Seurat object.
#' @param min_genes Minimum number of genes required to retain a gene set
#'   after intersecting with \code{rownames(seu_obj)}.
#'
#' @return A filtered named list of gene sets, containing only genes present
#'   in \code{seu_obj} and with at least \code{min_genes} genes.
#'
#' @keywords internal
.filter_gene_sets_for_obj <- function(gs_list, seu_obj, min_genes = 5) {
  genes <- rownames(seu_obj)
  out <- lapply(gs_list, function(g) intersect(g, genes))
  out[vapply(out, length, 1L) >= min_genes]
}

#' Add log2 fold-change columns between two sets of UCell scores
#'
#' This internal helper computes log2 fold-change between a set of "pre"
#' UCell scores and matching "post" scores stored in the Seurat object's
#' metadata. It searches for columns ending in \code{pre_suffix} and
#' expects matching columns where \code{pre_suffix} is replaced by
#' \code{post_suffix}. For each pathway, it adds a new column with suffix
#' \code{logfc_suffix}:
#'
#' \deqn{logFC = \log_2 \left( \frac{\mathrm{post} + \varepsilon}{\mathrm{pre} + \varepsilon} \right)}
#'
#' @param seurat_obj A Seurat object with UCell scores stored in
#'   \code{seurat_obj@meta.data}.
#' @param pre_suffix Character suffix used to identify baseline columns
#'   (e.g. \code{"_M6_RNA"}).
#' @param post_suffix Character suffix used to identify perturbation columns
#'   (e.g. \code{"_M6_M6up"}).
#' @param logfc_suffix Character suffix used for the new logFC columns
#'   (e.g. \code{"_M6_logFC"}).
#' @param eps Small numeric constant added to both pre and post scores to
#'   avoid division by zero in the log-ratio.
#'
#' @return The input Seurat object with additional logFC columns added to
#'   \code{seurat_obj@meta.data}.
#'
#' @keywords internal
.add_logfc_scores <- function(
  seurat_obj,
  pre_suffix,
  post_suffix,
  logfc_suffix,
  eps = 1e-10
) {
  meta <- seurat_obj@meta.data
  pre_cols <- grep(paste0(pre_suffix, "$"), colnames(meta), value = TRUE)

  for (pre_col in pre_cols) {
    post_col <- sub(paste0(pre_suffix, "$"), post_suffix, pre_col)
    if (!post_col %in% colnames(meta)) next

    base <- sub(paste0(pre_suffix, "$"), "", pre_col)
    logfc_name <- paste0(base, logfc_suffix)

    pre_vec  <- meta[[pre_col]]
    post_vec <- meta[[post_col]]

    seurat_obj@meta.data[[logfc_name]] <-
      log2((post_vec + eps) / (pre_vec + eps))
  }

  seurat_obj
}

#' Summarize pathway scores across cells or groups
#'
#' This internal helper summarizes columns in \code{seurat_obj@meta.data}
#' whose names match \code{score_pattern} (e.g. all logFC columns ending
#' in \code{"M6_logFC"}). If \code{group.by} is provided, scores are
#' summarized within each group; otherwise, a single row summarizing all
#' cells is returned.
#'
#' @param seurat_obj A Seurat object with per-cell score columns in
#'   \code{seurat_obj@meta.data}.
#' @param score_pattern Regular expression used to select score columns
#'   (e.g. \code{"_logFC$"}).
#' @param group.by Optional metadata column name used to group cells prior
#'   to summarization. If \code{NULL}, all cells are treated as one group.
#' @param fun Aggregation function to use for summarization, one of
#'   \code{"mean"} or \code{"median"}.
#'
#' @return A data frame with one row per group (or a single row if
#'   \code{group.by} is \code{NULL}), containing the group label, number
#'   of cells, and the aggregated scores for each selected column.
#'
#' @keywords internal
#' @note Currently unused by AlertSystemScore; kept for potential reuse.

.summarize_module_scores <- function(
  seurat_obj,
  score_pattern = "_logFC$",   # generic default
  group.by      = NULL,
  fun           = c("mean", "median")
) {
  fun <- match.arg(fun)
  meta <- seurat_obj@meta.data

  score_cols <- grep(score_pattern, colnames(meta), value = TRUE)
  if (length(score_cols) == 0L) {
    stop("No columns match score_pattern: ", score_pattern)
  }

  agg_fun <- if (fun == "mean") base::mean else stats::median

  # No grouping: summarize across all cells
  if (is.null(group.by)) {
    n_cells <- nrow(meta)
    vals <- vapply(
      score_cols,
      function(col) agg_fun(meta[[col]], na.rm = TRUE),
      FUN.VALUE = numeric(1L)
    )
    df <- data.frame(
      group   = "all_cells",
      n_cells = n_cells,
      t(vals),
      row.names   = NULL,
      check.names = FALSE
    )
    return(df)
  }

  # Grouped summary
  if (!group.by %in% colnames(meta)) {
    stop("group.by column not found: ", group.by)
  }

  split_idx   <- split(seq_len(nrow(meta)), meta[[group.by]])
  group_names <- names(split_idx)

  metric_list <- lapply(
    score_cols,
    function(col) {
      vapply(
        split_idx,
        function(idx) agg_fun(meta[[col]][idx], na.rm = TRUE),
        FUN.VALUE = numeric(1L)
      )
    }
  )

  metric_mat <- do.call(cbind, metric_list)
  colnames(metric_mat) <- score_cols
  rownames(metric_mat) <- group_names

  df <- data.frame(
    group   = rownames(metric_mat),
    n_cells = vapply(split_idx, length, FUN.VALUE = integer(1L)),
    metric_mat,
    row.names   = NULL,
    check.names = FALSE
  )
  names(df)[1] <- group.by
  df
}



#' Compute concordance and robustness metrics for AlertSystem
#'
#' For each group × pathway (logFC column) this computes:
#' - effect    : mean or median logFC (matching `fun`)
#' - concordance : fraction of cells whose logFC sign matches the group effect sign
#' - robust_gt_thresh : fraction of cells whose logFC is both:
#'       (i) above the magnitude threshold (|logFC| ≥ robust_effect_thresh) and
#'       (ii) has the same sign as the group-level effect.
#'
#' This replaces the previous bootstrap-based credibility metric, which tended to
#' saturate at 0/1 for large cell numbers. Robustness is now defined directly
#' from the per-cell logFC distribution.
#'
#' @keywords internal

.compute_alert_metrics <- function(
  seurat_obj,
  score_pattern        = "_logFC$",
  group.by             = NULL,
  fun                  = c("mean", "median"),
  compute_concordance  = TRUE,
  compute_robustness   = TRUE,
  robust_effect_thresh = 0,
  # NEW:
  base_tag             = NULL,
  pert_tag             = NULL
) {
  fun  <- match.arg(fun)
  meta <- seurat_obj@meta.data

  score_cols <- grep(score_pattern, colnames(meta), value = TRUE)
  if (length(score_cols) == 0L) {
    stop("No columns match score_pattern for metrics computation: ", score_pattern)
  }

  agg_fun <- if (fun == "mean") base::mean else stats::median

  if (is.null(group.by)) {
    split_idx   <- list(all_cells = seq_len(nrow(meta)))
    group_names <- "all_cells"
  } else {
    if (!group.by %in% colnames(meta)) {
      stop("group.by column not found for metrics computation: ", group.by)
    }
    split_idx   <- split(seq_len(nrow(meta)), meta[[group.by]])
    group_names <- names(split_idx)
  }

  # NEW: deterministic suffix
  logfc_suffix <- if (!is.null(base_tag)) paste0("_", base_tag, "_logFC") else NULL

  out_list <- list()

  for (g in seq_along(split_idx)) {
    idx   <- split_idx[[g]]
    gname <- group_names[g]

    for (col in score_cols) {
      vals <- meta[[col]][idx]
      vals <- vals[!is.na(vals)]

      if (length(vals) == 0L) {
        effect <- concordance <- robust_thr <- NA_real_
      } else {
        effect <- agg_fun(vals)

        if (compute_concordance) {
          s <- sign(effect)
          concordance <- if (s == 0) 0 else mean(sign(vals) == s)
        } else {
          concordance <- NA_real_
        }

        if (compute_robustness && robust_effect_thresh > 0) {
          s <- sign(effect)
          if (s == 0) {
            robust_thr <- 0
          } else {
            strong_and_consistent <- (abs(vals) >= robust_effect_thresh) & (sign(vals) == s)
            robust_thr <- mean(strong_and_consistent)
          }
        } else {
          robust_thr <- NA_real_
        }
      }

      # -------- NEW: pathway name extraction --------
      pathway <- col
      if (!is.null(logfc_suffix)) {
        pathway <- sub(paste0(logfc_suffix, "$"), "", pathway)
      } else {
        pathway <- sub("_logFC$", "", pathway)
      }

      # If the perturbation tag got baked into the pathway label, strip it only at the end
      if (!is.null(pert_tag) && nzchar(pert_tag)) {
        pathway <- sub(paste0("_", pert_tag, "$"), "", pathway)
      }
      # ---------------------------------------------

      out_list[[length(out_list) + 1L]] <- data.frame(
        group           = gname,
        pathway         = pathway,
        score_name      = col,
        n_cells         = length(vals),
        effect          = effect,
        concordance     = concordance,
        robust_gt_thresh = robust_thr,
        stringsAsFactors = FALSE
      )
    }
  }

  do.call(rbind, out_list)
}
