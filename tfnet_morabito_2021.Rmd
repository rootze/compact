
```{r eval=FALSE}

library(Seurat)
library(tidyverse)
library(cowplot)
library(patchwork)
library(WGCNA)
library(Matrix)
library(viridis)
library(harmony)
library(RColorBrewer)
library(ggpubr)
library(tictoc)
library(RColorBrewer)
# library(Hmisc)
# library(corrplot)
library(enrichR)
library(GeneOverlap)
library(grid)
library(gridExtra)
library(igraph)
library(ggrepel)
library(hdWGCNA)
enableWGCNAThreads(nThreads = 8)
theme_set(theme_cowplot())
set.seed(12345)


source('/dfs7/swaruplab/smorabit/analysis/scWGCNA/perturb/bin/TF_functions.R')

# for motif analysis 
# add instructions for separate install
library(JASPAR2020)
library(motifmatchr)
library(TFBSTools)
library(EnsDb.Hsapiens.v86)
library(BSgenome.Hsapiens.UCSC.hg38)
library(GenomicRanges)

# spatial plotting functions
source('/dfs7/swaruplab/smorabit/analysis/scWGCNA/bin/spatial_functions.R')

#devtools::install_github('smorabit/hdWGCNA', ref='dev')

load('/dfs7/swaruplab/smorabit/analysis/AD_NucSeq_2019/batch_correction/liger/update/celltype-analysis/data/color_scheme.rda')
cp <- unlist(color_scheme_snRNA_celltype)
cp[names(cp) == 'EX'] <- 'turquoise'


setwd('/dfs7/swaruplab/smorabit/analysis/scWGCNA/pertub/tfnet_morabito/')
fig_dir <- 'figures/'
data_dir <- 'data/'

# load Morabito et al 2021 dataset
seurat_obj <- readRDS("/dfs7/swaruplab/smorabit/analysis/scWGCNA/data/Swarup_2021.rds")

```

Run hdWGCNA on the oligodendrocytes 

```{r eval=FALSE}



```  


hdWGCNA motif scan

```{r eval=FALSE}

seurat_obj <- readRDS(file=paste0(data_dir, 'zhou_tutorial.rds'))

pfm_core <- TFBSTools::getMatrixSet(
  x = JASPAR2020,
  opts = list(collection = "CORE", tax_group = 'vertebrates', all_versions = FALSE)
)

# run the motif scan with these settings for the mouse dataset
seurat_obj <- MotifScan(
  seurat_obj,
  species_genome = 'hg38',
  pfm = pfm_core,
  EnsDb = EnsDb.Hsapiens.v86
)

```

Run the XGBoost TF network construction function 

```{r eval=FALSE}


library(xgboost)
library(tictoc)

motif_matrix <- GetMotifMatrix(seurat_obj)
motif_df <- GetMotifs(seurat_obj)
motif_df <- subset(motif_df, gene_name %in% rownames(seurat_obj))
head(motif_df)

# set up XGBoost model parameters
model_params <- list(
  objective = 'reg:squarederror',
  max_depth = 1,
  eta = 0.1,
  nthread=16,
  alpha=0.5,
  n_estimators=50
)
nfold=5

#---------------------------------------------------------------------------
# Set the expression matrix that we will use for the TF network analysis
#---------------------------------------------------------------------------

# keep all TFs, and then keep all non-grey genes 
tf_genes <- unique(motif_df$gene_name)
modules <- GetModules(seurat_obj)
nongrey_genes <- subset(modules, module != 'grey') %>% .$gene_name
genes_use <- c(tf_genes, nongrey_genes)


# should I make a way to directly give features to setdatexpr instead of doing this?
seurat_obj <- SetWGCNAGenes(seurat_obj, genes_use)
seurat_obj <- SetDatExpr(seurat_obj, group.by = 'cell_type', group_name='INH')
datExpr <- GetDatExpr(seurat_obj)
dim(datExpr)

#---------------------------------------------------------------------------
# Construct the TF net
#---------------------------------------------------------------------------

seurat_obj <- ConstructTFNetwork(
    seurat_obj,
    model_params=list(
        objective = 'reg:squarederror',
        max_depth = 1,
        eta = 0.1,
        nthread=16,
        alpha=0.5,
        n_estimators=50
    ),
    wgcna_name = 'tutorial'
)

#---------------------------------------------------------------------------
# Assign TF regulons
#---------------------------------------------------------------------------

seurat_obj <- AssignTFRegulons(
    seurat_obj,
    strategy = "A",
    reg_thresh = 0.01,
    n_tfs = 10
)
tf_regulons <- GetTFRegulons(seurat_obj)


#---------------------------------------------------------------------------
# Compute positive and negative regulon scores
#---------------------------------------------------------------------------

# positive regulons
seurat_obj <- RegulonScores(
    seurat_obj,
    target_type = 'positive',
    ncores=8
)

# negative regulons
seurat_obj <- RegulonScores(
    seurat_obj,
    target_type = 'negative',
    cor_thresh = -0.05,
    ncores=8
)
regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive')
head(regulon_scores)



# save the seurat obj with this info
saveRDS(seurat_obj, file=paste0(data_dir, 'zhou_tutorial_tfs.rds'))


```

Code for differential regulon analysis 

```{r eval=FALSE}

# make this code into a function later!!!!

FindDifferenialRegulons <- function(
  seurat_obj,
  barcodes1,
  barcodes2,
  target_type='positive',
  wgcna_name=NULL,
  test.use='wilcox',
  only.pos=FALSE,
  logfc.threshold = 0,
  min.pct=0,
  verbose=FALSE,
  pseudocount.use=0,
  ...
){

  if(is.null(wgcna_name)){wgcna_name <- seurat_obj@misc$active_wgcna}
  if(!CheckWGCNAName(seurat_obj, wgcna_name)){
    stop(paste0("Invalid wgcna_name supplied: ", wgcna_name))
  }  

  # ensure that selected barcodes are in the seurat obj
  if(!(all(barcodes1 %in% colnames(seurat_obj)))){
    stop('Some barcodes in barcodes1 not found in colnames(seurat_obj).')
  }
  if(!(all(barcodes2 %in% colnames(seurat_obj)))){
    stop('Some barcodes in barcodes2 not found in colnames(seurat_obj).')
  }

  # check for overlap in the two groups of bacrodes:
  if(length(intersect(barcodes1, barcodes2)) > 0){
    stop('Some barcodes overlap in barcodes1 and barcodes2')
  }

  # get regulon scores
  regulon_scores <- GetRegulonScores(
    seurat_obj, 
    target_type = target_type, 
    wgcna_name = wgcna_name
  )

  # create new assay for regulons:
  reg_assay <- Seurat::CreateAssayObject(t(regulon_scores))

  # run differential test on the reg assay
  dregs <- FindMarkers(
    reg_assay,
    cells.1 = barcodes1,
    cells.2 = barcodes2,
    slot='counts',
    test.use=test.use,
    only.pos=only.pos,
    logfc.threshold=logfc.threshold,
    min.pct=min.pct,
    verbose=verbose,
    pseudocount.use=pseudocount.use,
    ...
  )
  dregs$tf <- rownames(dregs)

  dregs

}


########################################
# pt1: differential regulons
########################################

target_type <- 'positive'
target_type <- 'negative'

group1 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex == 0) %>% rownames
group2 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex != 0) %>% rownames

dregs <- FindDifferenialRegulons(
  seurat_obj,
  target_type = target_type,
  barcodes1 = group1,
  barcodes2 = group2,
  test.use='wilcox',
  wgcna_name='tutorial'
)

########################################
# pt2: DEGs of just these TFs
########################################

tf_regulons <- GetTFRegulons(seurat_obj)
regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive')
modules <- GetModules(seurat_obj)

tf_genes <- colnames(regulon_scores)

X <- LayerData(seurat_obj, layer='data')[tf_genes,]
exp_assay <- Seurat::CreateAssayObject(X)

degs <- FindMarkers(
    exp_assay,
    cells.1 = group1,
    cells.2 = group2,
    slot='data',
    test.use='wilcox',
    only.pos=FALSE,
    logfc.threshold=0,
    min.pct=0 ,
    verbose=TRUE,
    pseudocount.use=0
)
degs$gene <- rownames(degs)

# next follow the 

# join them together!!!


plot_df <- dplyr::inner_join(
  dregs %>% dplyr::rename(gene = tf), 
  degs %>% dplyr::select(c(p_val_adj, avg_log2FC, gene)), 
  by = 'gene'
) 

# add module info: 
tf_modules <- modules %>% subset(gene_name %in% plot_df$gene)
plot_df$module <- tf_modules[plot_df$gene,'module']
plot_df$color <- tf_modules[plot_df$gene,'color']

# color scheme
mod_colors <- dplyr::select(modules, c(module, color)) %>%
  distinct
mod_cp <- mod_colors$color; names(mod_cp) <- mod_colors$module


plot_range <- max(c(abs(range(plot_df$avg_log2FC.y)), abs(range(plot_df$avg_log2FC.x))))

logfc_thresh <- 0.1

# annotations for the corners 
up_right <- plot_df %>% subset(avg_log2FC.x >= logfc_thresh & avg_log2FC.y >= logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% nrow
down_right <- plot_df %>% subset(avg_log2FC.x >= logfc_thresh & avg_log2FC.y <= -logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% nrow
up_left <- plot_df %>% subset(avg_log2FC.x <= -logfc_thresh & avg_log2FC.y >= logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% nrow
down_left <- plot_df %>% subset(avg_log2FC.x <= -logfc_thresh & avg_log2FC.y <= -logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% nrow

# labels for the top genes 
if(target_type == 'positive'){
    up_genes <- plot_df %>% subset(avg_log2FC.x >= logfc_thresh & avg_log2FC.y >= logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% .$gene
    down_genes <- plot_df %>% subset(avg_log2FC.x <= -logfc_thresh & avg_log2FC.y <= -logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% .$gene
} else if(target_type == 'negative'){
    up_genes <- plot_df %>% subset(avg_log2FC.x <= -logfc_thresh & avg_log2FC.y >= logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% .$gene
    down_genes <- plot_df %>% subset(avg_log2FC.x >= logfc_thresh & avg_log2FC.y <= -logfc_thresh & (p_val_adj.y <= 0.05 | p_val_adj.x <= 0.05)) %>% .$gene
}
label_genes <- c(up_genes, down_genes)

plot_df$label <- ifelse(plot_df$gene %in% label_genes, plot_df$gene, '')

annotations <- data.frame(
        xpos = c(-Inf,-Inf,Inf,Inf),
        ypos =  c(-Inf, Inf,-Inf,Inf),
        annotateText = c(as.character(down_left),as.character(up_left), as.character(down_right),as.character(up_right)),
        hjustvar = c(-1,-1,2,2),
        vjustvar = c(-1,2,-1,2)) #<- adjust

p <- plot_df %>% 
  ggplot(aes(x=avg_log2FC.x, y=avg_log2FC.y, color=module)) + 
  geom_hline(yintercept = 0, linetype='dashed', color='black', linewidth=0.25) +
  geom_vline(xintercept = 0, linetype='dashed', color='black', linewidth=0.25) +
  ggrastr::rasterise(geom_point(), dpi=500) +
  geom_smooth(inherit.aes=FALSE, data=plot_df, mapping = aes(x = avg_log2FC.x, y = avg_log2FC.y), method='lm', color='black') +
  stat_cor(
      inherit.aes=FALSE, 
      data=plot_df, 
      mapping = aes(x = avg_log2FC.x, y = avg_log2FC.y, label=..r.label..), 
      label.y = plot_range * 0.75,
      method='pearson'
    ) +
    xlim(c(-plot_range, plot_range)) +
    ylim(c(-plot_range, plot_range)) +
    scale_color_manual(values=mod_cp) +
    scale_size_continuous(range = c(0.5,4)) +
    theme(
      axis.line.x = element_blank(),
      axis.line.y = element_blank(),
     # axis.title.y = element_blank(),
     # axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill=NA, size=1),
      plot.title = element_text(hjust=0.5),
      panel.grid = element_line(size=0.25, color='white'),
      panel.background = element_rect(fill='grey92'),
    ) +
    ylab(bquote("Expression Avg. log"[2]~"(FC)")) +
    xlab(bquote("Regulon Avg. log"[2]~"(FC)")) +
    geom_text_repel(aes(label=label), max.overlaps=Inf, color='black', fontface='italic') +
    coord_fixed(ratio=1) + NoLegend() + 
    geom_text(inherit.aes=FALSE, data=annotations,aes(x=xpos,y=ypos,hjust=hjustvar,vjust=vjustvar,label=annotateText))



# Plot the result
pdf(paste0(fig_dir, 'diff_compare_regulon_exp_', target_type, '2.pdf'), height=4, width=4)
print(p)
dev.off()






```



Test making a network plot using tidygraph + ggraph 

```{r eval=FALSE}

library(ggraph)
library(tidygraph)
library(igraph)

cur_tf <- 'ZBTB33'


# get the regulons
regulons <- GetTFRegulons(seurat_obj)

# compute the degree for each TF:
tf_degrees <- table(regulons$tf)

#---------------------------------------------------------------------------#
# Get the primary & secondary targets of the cur tf
#---------------------------------------------------------------------------#

# primary target genes 
cur_primary<- regulons %>% 
subset(tf == cur_tf) 

# which of these pimary target genes are tfs?
cur_primary_tfs <- cur_primary %>% 
subset(gene %in% unique(regulons$tf)) %>% .$gene

cur_tfs <- unique(c(cur_tf, cur_primary_tfs))

# get the regulons for these TFs:
cur_secondary <- subset(regulons, tf %in% cur_primary_tfs)
cur_secondary_tfs <- cur_primary %>% 
subset(gene %in% unique(regulons$tf)) %>% .$gene

# combine the primary and secondary into one table 
cur_network <- rbind(cur_primary, cur_secondary)
cur_network$Gain <- cur_network$Gain * sign(cur_network$Cor)

cur_genes <- unique(cur_network$gene)
length(cur_genes)

# make an igraph network from the nr4a2 regulon:
cur_network <- cur_network %>%
dplyr::rename(c(source=tf, target=gene)) %>%
mutate(Score = sign(Cor) * Gain)

primary_genes <- unique(cur_primary$gene)
secondary_genes <- unique(cur_network$target[! cur_network$target %in% primary_genes])

# cutoff for correlation values
cor_cutoff <- 0.75
cur_network$Cor <- ifelse(abs(cur_network$Cor) > cor_cutoff, sign(cur_network$Cor) * cor_cutoff, cur_network$Cor)

#---------------------------------------------------------------------------#
# Plot with ggraph
#---------------------------------------------------------------------------#

graph <- as_tbl_graph(cur_network) %>% 
activate(nodes) %>% 
mutate(degree  = centrality_degree())  

tmp <- tf_degrees[names(V(graph))]; tmp <- tmp[!is.na(tmp)]
V(graph)[names(tmp)]$degree <- as.numeric(tmp)

V(graph)$gene_type <- ifelse(names(V(graph)) %in% unique(regulons$tf), 'TF', 'Gene')
V(graph)$gene_type <- ifelse(names(V(graph)) == cur_tf, cur_tf, V(graph)$gene_type)

set.seed(12345)
n_pivots <- 250
if(length(V(graph)) < n_pivots){
n_pivots <- length(V(graph)) / 2
}
lay <- create_layout(graph, layout='sparse_stress', pivots=n_pivots)

#lay <- create_layout(graph, layout='focus', focus = node_is_center())

# add extra info
# lay$tf_name <- ifelse(lay$name %in% unique(regulons$tf), lay$name, NA)
lay$tf_name <- ifelse(lay$name %in% c(cur_tf, cur_primary_tfs), lay$name, NA)
lay$size <- ifelse(lay$name %in% unique(regulons$tf), 5, 2)
lay$type <- ifelse(lay$name %in% primary_genes, 'Primary', 'Secondary')
lay$type <- ifelse(lay$name == cur_tf, cur_tf, lay$type)
lay$type <- factor(lay$type, levels = c(cur_tf, 'Primary', 'Secondary'))

# shape layout:
cur_shapes <- c(18, 17, 16); names(cur_shapes) <- c(cur_tf, 'TF', 'Gene')

p <- ggraph(lay) + 
geom_edge_link(
    aes(color=Cor, alpha=abs(Cor)),
    arrow = arrow(length = unit(1, 'mm'), type='closed'), 
                # size=0.5,
                # end_cap = circle(3, 'mm')
) + 
geom_node_point(data=subset(lay, (! name %in% regulons$tf) | name == cur_tf ), aes(color=type, shape=gene_type, size=degree)) +
geom_node_point(data=subset(lay, name %in% regulons$tf & name != cur_tf), aes(fill=type, size=degree), color='black', shape=25) +

# ggrastr::rasterise(geom_node_point(aes(color=type, size=degree)), dpi=200) +
#geom_node_text(aes(label=tf_name), repel=TRUE, max.overlaps=Inf, fontface='italic') +
geom_node_label(aes(label=tf_name), repel=TRUE, max.overlaps=Inf, fontface='italic') +
scale_edge_colour_gradient2(high='orange2', mid='white', low='dodgerblue')  + 
scale_colour_manual(values=c('black', 'darkorchid4', 'mediumpurple2')) + 
scale_fill_manual(values=c('darkorchid4', 'mediumpurple2')) + 
scale_shape_manual(values=cur_shapes) 

pdf(paste0(fig_dir, 'TFnetwork_',cur_tf, '.pdf'), width=8, height=7)
print(p)
dev.off()



p <- ggraph(lay) + 
geom_edge_link(
    aes(color=Cor, alpha=abs(Cor)),
    arrow = arrow(length = unit(1, 'mm'), type='closed'), 
                # size=0.5,
                # end_cap = circle(3, 'mm')
) + 
geom_node_point(data=subset(lay, (! name %in% regulons$tf) | name == cur_tf ), aes(color=type, shape=gene_type, size=degree)) +
geom_node_point(data=subset(lay, name %in% regulons$tf & name != cur_tf), aes(fill=type, size=degree), color='black', shape=25) +
scale_edge_colour_gradient2(high='orange2', mid='white', low='dodgerblue')  + 
scale_colour_manual(values=c('black', 'darkorchid4', 'mediumpurple2')) + 
scale_fill_manual(values=c('darkorchid4', 'mediumpurple2')) + 
scale_shape_manual(values=cur_shapes) + NoLegend()

pdf(paste0(fig_dir, 'TFnetwork_',cur_tf, '_nolabel.pdf'), width=5, height=5)
print(p)
dev.off()


```

